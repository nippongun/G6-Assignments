//SumoWrestling
#if 1
void motor_tR(uint8 speed,uint32 delay);    
void motor_tL(uint8 speed,uint32 delay);
void zmain(void)
{
    IR_Start();
    Ultra_Start();
    reflectance_start();
    LSM303D_Start();
    motor_start();
    struct sensors_ dig;
    struct accData_ data;
    float hit_x = 0;
    float hit_y = 0;
    float value_hit = 0;
    float angle;
    reflectance_set_threshold(9500, 7000, 13000, 12000, 7000, 9500);
    int distance = 0;
    vTaskDelay(1);
    motor_forward(0,0);
    reflectance_digital(&dig);
    distance = Ultra_GetDistance();
    LSM303D_Read_Acc(&data);
    
    //stop on the line//
  while(SW1_Read() != 0)
    {
        vTaskDelay(100);
    }
    reflectance_digital(&dig);
    while((dig.l3 == 0 || dig.r3 == 0) && (dig.l1 == 1 || dig.r1 == 1))
    {
        reflectance_digital(&dig);
        motor_forward(50,1);
    }
    if((dig.l3 == 1) && (dig.l2 == 1) && (dig.l1 == 1) && (dig.r1 == 1) && (dig.r2 == 1) && (dig.r3 == 1))
    {
        reflectance_digital(&dig); 
        while(dig.l3 == 1 || dig.r3 == 1)
        {
            reflectance_digital(&dig); 
            motor_forward(50,1);
        }
    }
    motor_forward(0,0); 
    //wait for IR remote//
    IR_wait();
    //First while loop meant to move around the ring in a constant speed//
    while(1)
    {
        distance = Ultra_GetDistance();
        reflectance_digital(&dig);
        if((distance>15))
        {
            reflectance_digital(&dig);
            distance = Ultra_GetDistance();
            while((dig.l2 == 0 || dig.r2 == 0))
            {
                motor_forward(150,1);
                distance = Ultra_GetDistance();
                reflectance_digital(&dig);
            }
        }
        distance = Ultra_GetDistance();
        reflectance_digital(&dig);
//if the robot gets a value over 4000 in x/y axis it will print in the mqtt the angle
//that the robot got hit
//if robot meets with the ring border then it will move a little bit backwards
//and then tank turn to the right & calculates the angle if got hit during the process
        if(dig.l3 == 1 || dig.l2 == 1)
        {
            distance = Ultra_GetDistance();
            motor_backward(200,100);
            reflectance_digital(&dig);
            motor_tR(220,250);
            print_mqtt("Zumo061/going", "right");
            //if the robot gets a value over 4000 in x/y axis it will print in the mqtt the angle
            //that the robot got hit
        }
        else if(dig.r3 == 1 || dig.r2 == 1)
        {
            distance = Ultra_GetDistance();
            motor_backward(200,100);
            reflectance_digital(&dig);
            motor_tL(220,250);
            print_mqtt("Zumo061/going", "left");
            //if the robot gets a value over 4000 in x/y axis it will print in the mqtt the angle
            //that the robot got hit
        }   
//if the robot detacts another robot under 15cm it rushes into the robot and always calculating hit angle
        distance = Ultra_GetDistance();
        reflectance_digital(&dig);
        if((distance < 15) || (distance > 75))
        {   
            reflectance_digital(&dig);
            distance = Ultra_GetDistance();
            while(dig.r2 == 0 || dig.l2 == 0)
            {
            distance = Ultra_GetDistance();
            motor_forward(230, 1);
            reflectance_digital(&dig);
            print_mqtt("Zumo061/going", "Target");
            }
            //if the robot gets a value over 4000 in x/y axis it will print in the mqtt the angle
            //that the robot got hit  
        }
        
        if(hit_x > 4000 || hit_y > 4000)
        {
            LSM303D_Read_Acc(&data);               
            hit_x = hit_x/16000;
            hit_y = hit_y/16000;
            value_hit = hit_x/hit_y;
            angle = ((atan(value_hit))*180)/M_PI;
            //we need to print out the angle so %.2f,angle
        }
 //here we got 3 different situation which the robots meets the border and do different task for each one
 //also always calculates the hit angle                   
    }
}
void motor_tR(uint8 speed,uint32 delay)
{
    MotorDirLeft_Write(0);      // set LeftMotor forward mode
    MotorDirRight_Write(1);     // set RightMotor backward mode
    PWM_WriteCompare1(speed); 
    PWM_WriteCompare2(speed); 
    vTaskDelay(delay);
}
void motor_tL(uint8 speed,uint32 delay)
{
    MotorDirLeft_Write(1);      // set LeftMotor backward mode
    MotorDirRight_Write(0);     // set RightMotor forward mode
    PWM_WriteCompare1(speed); 
    PWM_WriteCompare2(speed); 
    vTaskDelay(delay);
}
#endif
